import { trySafe } from '@silverhand/essentials';
import { useContext, useRef, useEffect, useCallback, useMemo } from 'react';
import { LogtoContext, throwContextError } from '../context.js';

const useErrorHandler = () => {
    const { setError } = useContext(LogtoContext);
    const handleError = useCallback((error, fallbackErrorMessage) => {
        if (error instanceof Error) {
            setError(error);
        }
        else if (fallbackErrorMessage) {
            setError(new Error(fallbackErrorMessage));
        }
        console.error(error);
    }, [setError]);
    return { handleError };
};
const useHandleSignInCallback = (callback) => {
    const { logtoClient, isAuthenticated, error, setIsAuthenticated, isLoading, setIsLoading } = useContext(LogtoContext);
    const { handleError } = useErrorHandler();
    const callbackRef = useRef();
    useEffect(() => {
        // eslint-disable-next-line @silverhand/fp/no-mutation
        callbackRef.current = callback; // Update ref to the latest callback.
    }, [callback]);
    useEffect(() => {
        if (!logtoClient || isLoading || error) {
            return;
        }
        (async () => {
            const currentPageUrl = window.location.href;
            const isRedirected = await logtoClient.isSignInRedirected(currentPageUrl);
            if (!isAuthenticated && isRedirected) {
                setIsLoading(true);
                await trySafe(async () => {
                    await logtoClient.handleSignInCallback(currentPageUrl);
                    setIsAuthenticated(true);
                    callbackRef.current?.();
                }, (error) => {
                    handleError(error, 'Unexpected error occurred while handling sign in callback.');
                });
                setIsLoading(false);
            }
        })();
    }, [
        error,
        handleError,
        isAuthenticated,
        isLoading,
        logtoClient,
        setIsAuthenticated,
        setIsLoading,
    ]);
    return {
        isLoading,
        isAuthenticated,
        error,
    };
};
const useLogto = () => {
    const { logtoClient, isAuthenticated, error, isLoading, setIsLoading } = useContext(LogtoContext);
    const { handleError } = useErrorHandler();
    const client = logtoClient ?? throwContextError();
    const proxy = useCallback((run, resetLoadingState = true) => {
        return async (...args) => {
            try {
                setIsLoading(true);
                return await run(...args);
            }
            catch (error) {
                handleError(error, `Unexpected error occurred while calling ${run.name}.`);
            }
            finally {
                if (resetLoadingState) {
                    setIsLoading(false);
                }
            }
        };
    }, [setIsLoading, handleError]);
    const methods = useMemo(() => ({
        getRefreshToken: proxy(client.getRefreshToken.bind(client)),
        getAccessToken: proxy(client.getAccessToken.bind(client)),
        getAccessTokenClaims: proxy(client.getAccessTokenClaims.bind(client)),
        getOrganizationToken: proxy(client.getOrganizationToken.bind(client)),
        getOrganizationTokenClaims: proxy(client.getOrganizationTokenClaims.bind(client)),
        getIdToken: proxy(client.getIdToken.bind(client)),
        getIdTokenClaims: proxy(client.getIdTokenClaims.bind(client)),
        // eslint-disable-next-line no-restricted-syntax -- TypeScript cannot infer the correct type.
        signIn: proxy(client.signIn.bind(client), false),
        // We deliberately do NOT set isAuthenticated to false in the function below, because the app state
        // may change immediately even before navigating to the oidc end session endpoint, which might cause
        // rendering problems.
        // Moreover, since the location will be redirected, the isAuthenticated state will not matter any more.
        signOut: proxy(client.signOut.bind(client)),
        fetchUserInfo: proxy(client.fetchUserInfo.bind(client)),
        clearAccessToken: proxy(client.clearAccessToken.bind(client)),
        clearAllTokens: proxy(client.clearAllTokens.bind(client)),
    }), [client, proxy]);
    return {
        isAuthenticated,
        isLoading,
        error,
        ...methods,
    };
};

export { useHandleSignInCallback, useLogto };
